class Treenode {
public:
	int data;
	Treenode * right ;
	Treenode * left ;

	// constructor
	Treenode(int da ) : data(da), right(nullptr), left(nullptr) {}
};

// --- traversals
void bst_traversal_inOrder(Treenode * root) {
	if (root == nullptr)
		return;
	bst_traversal_inOrder(root->left);
	cout << root->data << " ";
	bst_traversal_inOrder(root->right);
}

void bst_traversal_postOrder(Treenode * root) {
	if (root == nullptr)
		return;
	bst_traversal_postOrder(root->left);
	bst_traversal_postOrder(root->right);
	cout << root->data << " ";
}

void bst_traversal_PreOrder(Treenode * root) {
	if (root == nullptr)
		return;
	cout << root->data << " ";
	bst_traversal_PreOrder(root->left);
	bst_traversal_PreOrder(root->right);

}


void bst_levelOrder(Treenode * root) {
	cout << "\n\n\n ----- level order traversal function \n";
	if (root == nullptr)
		return;
	queue<Treenode *> q {};
	q.push(root);

	while (!q.empty()) {
		int lvl_size = q.size();
		for (int i = 0; i < lvl_size; ++i) {
			Treenode * tempTreenode = q.front();
			cout << tempTreenode->data << " ";
			q.pop();
			if (tempTreenode->left) {
				q.push(tempTreenode->left);
			}
			if (tempTreenode->right) {
				q.push(tempTreenode->right);
			}
		}
		cout << "\n";
	}
}
// --- insertion
Treenode * bst_insertTreenode(Treenode * root, int d) {
	if (root == nullptr) {
		return root = new Treenode(d);
	}

	if (root->data > d)
		root->left = bst_insertTreenode(root->left, d);
	else
		root->right = bst_insertTreenode(root->right, d);
}
void bst_vector(Treenode * &root, vector<int> nums) {
	cout << "adding Treenodes to the root Treenode ..\n";
	for (int it : nums) {
		cout << "adding Treenode : " << it << "\n";
		root = bst_insertTreenode(root, it);
	}
	cout << "Treenodes added to the root Treenode ..\n";
}
